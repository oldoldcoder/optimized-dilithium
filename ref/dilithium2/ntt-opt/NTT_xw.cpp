#include <cstring>
#include <cstdint>
#include "random"

/*-----------------------常量定义---------------------*/
#define N 256
#define logN 8
#define pVec 8380417                            //各个素数
#define invp 58728449                           //pvec的原根的逆原
#define primeLen 23                             //pVec的长度
#define inv 8364049                             //M的逆

uint32_t g[N >> 1] = {
        4193792,381987,2348700,177440,6271868,6927966,7426187,8371839,2091905,4968207,3077325,3628969,8360995,8253495,4873154,904516,777960,7072248,4519302,5220671,1024112,3041255,5582638,2389356,5268920,4686924,4464978,7094748,6980856,6441103,4558682,5037034,2608894,1852771,300467,1341330,7830929,6203962,531354,3249728,6554070,2147896,8284641,4499357,8100412,3190144,6779997,1100098,466468,7709315,4805995,4827145,4794489,3930395,3900724,7620448,5495562,2477047,1661693,7567685,3859737,7380215,6681150,7871466,25847,7031341,7841118,5971092,5760665,3475950,4499374,3724342,8021166,983419,3530437,4540456,6623180,4747489,2140649,3958618,237124,22981,5336701,1851402,5654953,4702672,6308525,8169440,5700314,2967645,5842901,1584928,5102745,7122806,4874723,264944,518909,6949987,3539968,7064828,7260833,1585221,7568473,1653064,6026966,2715295,2706023,3019102,4010497,3157330,3699596,44288,876248,7151892,2867647,8190869,7300517,1528703,5823537,1316856,5260684,7969390,3592148,6940675,6262231,4083598,6736599,5282425};
uint32_t gi[N >> 1] = {
        4193792,3097992,1643818,4296819,2118186,1439742,4788269,411027,3119733,7063561,2556880,6851714,1079900,189548,5512770,1228525,7504169,8336129,4680821,5223087,4369920,5361315,5674394,5665122,2353451,6727353,811944,6795196,1119584,1315589,4840449,1430430,7861508,8115473,3505694,1257611,3277672,6795489,2537516,5412772,2680103,210977,2071892,3677745,2725464,6529015,3043716,8357436,8143293,4421799,6239768,3632928,1757237,3839961,4849980,7396998,359251,4656075,3881043,4904467,2619752,2409325,539299,1349076,8354570,508951,1699267,1000202,4520680,812732,6718724,5903370,2884855,759969,4479693,4450022,3585928,3553272,3574422,671102,7913949,7280319,1600420,5190273,280005,3881060,95776,6232521,1826347,5130689,7849063,2176455,549488,7039087,8079950,6527646,5771523,3343383,3821735,1939314,1399561,1285669,3915439,3693493,3111497,5991061,2797779,5339162,7356305,3159746,3861115,1308169,7602457,7475901,3507263,126922,19422,4751448,5303092,3412210,6288512,8578,954230,1452451,2108549,8202977,6031717,7998430};

// 提前预计算出来的rev的数值
int rev[N] = {0,128,64,192,32,160,96,224,16,144,80,208,48,176,112,240,8,136,72,200,40,168,104,232,24,152,88,216,56,184,120,248,4,132,68,196,36,164,100,228,20,148,84,212,52,180,116,244,12,140,76,204,44,172,108,236,28,156,92,220,60,188,124,252,2,130,66,194,34,162,98,226,18,146,82,210,50,178,114,242,10,138,74,202,42,170,106,234,26,154,90,218,58,186,122,250,6,134,70,198,38,166,102,230,22,150,86,214,54,182,118,246,14,142,78,206,46,174,110,238,30,158,94,222,62,190,126,254,1,129,65,193,33,161,97,225,17,145,81,209,49,177,113,241,9,137,73,201,41,169,105,233,25,153,89,217,57,185,121,249,5,133,69,197,37,165,101,229,21,149,85,213,53,181,117,245,13,141,77,205,45,173,109,237,29,157,93,221,61,189,125,253,3,131,67,195,35,163,99,227,19,147,83,211,51,179,115,243,11,139,75,203,43,171,107,235,27,155,91,219,59,187,123,251,7,135,71,199,39,167,103,231,23,151,87,215,55,183,119,247,15,143,79,207,47,175,111,239,31,159,95,223,63,191,127,255};                                 //蝶形变幻的索引

/*-----------------------具体函数----------------------*/
// bit反转， 蝶形变换 TODO 我自己给改成静态的了
/*void bitreverse(){
    int revint[N];
    for (int i = 0; i < N; ++i)
    {
        revint[i] = 0;
        rev[i] = i;
    }
    for (int i = 0; i < N; ++i){				// get rev
        revint[i] = (revint[i >> 1] >> 1) | ((i & 1) << (logN - 1));
        if(i < revint[i]){
            rev[revint[i]] = i;
            rev[i] = revint[i];
        }
    }
}*/

// 交换函数
void swap(uint32_t &a, uint32_t &b) {
    uint32_t temp = a;
    a = b;
    b = temp;
}

// 模乘运算
void mulMod(uint32_t &r, uint32_t  a, uint32_t  b, uint32_t  m) {
    uint64_t mul = static_cast<uint64_t>(a) * b;
    mul %= static_cast<uint64_t>(m);
    r = static_cast<uint32_t>(mul);
}


uint32_t REDC(uint32_t a, uint32_t b){
    uint64_t U = static_cast<uint64_t>(a) * b;
    auto U0 = static_cast<uint64_t>(U);
    uint32_t U1 = U >> 32;
    uint32_t Q = U0 * invp;
    uint64_t Hx = static_cast<uint64_t>(Q) * pVec;
    uint32_t H = Hx >> 32;
    uint32_t V = U1 < H ? U1 + pVec - H : U1 - H;
    return V;
}

void NTT(uint32_t a[N])
{
    int NLess2 = N >> 1;

    uint32_t temp_a[N];
    for (int i = 0; i < NLess2; i++)
    {
        temp_a[i] = (a[rev[2 * i]] + a[rev[2 * i + 1]]) % pVec;
        temp_a[i + NLess2] = (a[rev[2 * i]] - a[rev[2 * i + 1]] + pVec) % pVec;
    }

    memcpy(a, temp_a, sizeof(temp_a));
    for (int i = 1; i < logN; i++){
        int shift = logN - 1 - i;
        for (int j = 0; j < NLess2; j++){
            int P = (j >> shift) << shift;
            uint32_t odd = REDC(a[2 * j + 1], g[P]);
            temp_a[j] = (a[2 * j] + odd) % pVec;
            temp_a[j + NLess2] = (a[2 * j] - odd + pVec) % pVec;
        }
        memcpy(a, temp_a, sizeof(temp_a));
    }
}

void INTT(uint32_t a[N])                                             //NTT，type=1, or is INTT
{
    int NLess2 = N >> 1;

    uint32_t temp_a[N];
    for (int i = 0; i < NLess2; i++)
    {
        temp_a[i] = (a[rev[2 * i]] + a[rev[2 * i + 1]]) % pVec;
        temp_a[i + NLess2] = (a[rev[2 * i]] - a[rev[2 * i + 1]] + pVec) % pVec;
    }

    memcpy(a, temp_a, sizeof(temp_a));

    for (int i = 1; i < logN; i++){
        int shift = logN - 1 - i;
        for (int j = 0; j < NLess2; j++){
            int P = (j >> shift) << shift;
            uint32_t odd = REDC(a[2 * j + 1], gi[P]);
            // mulModBarrett(odd, a[2 * j + 1], gi[P], pVec, prVec);
            temp_a[j] = (a[2 * j] + odd) % pVec;
            temp_a[j + NLess2] = (a[2 * j] - odd + pVec) % pVec;
        }
        memcpy(a, temp_a, sizeof(temp_a));
    }

    for (int i = 0; i < N; i++)
    {
        // mulModBarrett(a[i], a[i], inv, pVec, prVec);
        a[i] = REDC(a[i], inv);
    }

}

void NTTtest3(){
    // printf("%llu\n",pVec[0]);
    auto *a = new uint32_t[N];
    auto *b = new uint32_t[N];
    for (int i = 0; i < N; ++i)                            //输入第一个多项式
    {
        a[i] = rand() % pVec;
        b[i] = rand() % pVec;	     						//输入第二个多项式
    }

    auto *c = new uint32_t[N];
    for (size_t i = 0; i < N; i++)
    {
        c[i] = 0;
    }

    for (size_t i = 0; i <  N; i++)
    {
        for (size_t j = 0; j < N; j++)
        {
            uint32_t temp = 0;
            mulMod(temp, a[i], b[j], pVec);
            c[(i+j) % N] += temp;
            c[(i+j) % N] %= pVec;
        }
    }

    NTT(a);                                           //系数表示法转点值表示法
    NTT(b);

    for (int i = 0; i < N; ++i)
        mulMod(a[i], a[i], b[i], pVec);                  //O(n)乘法
    printf("\n");
    INTT(a);                                           //点值表示法转系数表示法

    for (int i = 0; i < N; ++i)
    {
        printf("%d ", c[i] - a[i]);
    }
    printf("\n");
}
