#include <cstring>
#include <cstdint>
#include "ntt.hpp"

/*-----------------------常量定义---------------------*/
#define N 256
#define logN 8
#define pVec 8380417                            //各个素数
#define invp 58728449                           //pvec的原根的逆原
#define primeLen 23                             //pVec的长度
#define inv 8364049                             //M的逆

int g[N >> 1] = {
        4193792,156297,2846794,16042,1040321,5178690,8089838,635869,2675580,6203322,2601990,4786951,5410603,8170297,330392,7482727,7291220,148018,7585512,2348454,1996665,830249,7029414,6534862,5625892,3530404,5168724,1222593,6646137,8353922,1006062,6165243,4195315,6042868,1041859,3094933,624260,3766378,5508808,5419255,7931127,5435394,1672797,6855714,1425419,3489966,6155181,7451355,2695034,7755441,8215843,7526858,3592300,6932232,4176864,5409916,5981347,5429955,6712863,852886,8375626,6149884,6430204,2016993,8331699,6890586,7960289,2356386,2855841,7880359,3483515,5633921,5667926,4860363,3311213,5360507,3599740,2603367,5246790,372583,7748510,3034060,2132129,209609,7724780,2080111,100162,7920609,4299627,5303506,347957,1835410,2121094,3170080,7464540,5951647,7835851,7955772,6092538,2047954,5783467,3913802,1103261,6202181,1867081,8372631,4363809,2863620,526447,2164127,6905793,4130411,7921877,3150182,6038177,4362615,7847329,1848331,6674068,2057970,2855731,7640233,1581516,3621766,6453462,3724829,6383954,3143641
};
int gi[N >> 1] = {
        4193792,6866139,6190511,8370968,3873963,7081058,2148831,5485683,421442,6641271,5139555,3593235,414165,6359892,5381365,1984371,7913444,1589066,6094433,6152954,4093608,1746100,4556994,179078,2949267,156098,2490460,462218,4875172,1310126,5550877,6896403,5735707,2676649,6178052,8045682,6644194,889913,3967198,2048556,3383641,3156308,1762155,2125594,5935942,1960625,6325538,3387717,7805327,6945481,7321740,5713577,5921473,2998826,8378010,4889070,63675,6768900,5025909,3682563,7285764,7692780,3224360,7930287,8295264,1175024,1227742,3900205,2112136,3668466,6882871,6162808,6699381,1226596,6177016,5455758,8275156,2206033,4803541,5955677,7334328,6903153,5268747,7021599,5385356,831472,3096216,2047727,660491,5886120,3060200,5878087,6707917,4228833,3761804,2175836,7952550,7611791,359794,6376468,8120680,7916604,3249881,704597,1206411,8018288,5934674,5971621,6149117,3625981,3976350,4531701,7866030,5402995,6723195,4942628,1374407,6924736,100683,2085675,5630897,5671458,6389394,4904783,5109885,7497750,7218585,8280327
};

// 提前预计算出来的rev的数值
int rev[N] = {0,128,64,192,32,160,96,224,16,
              144,80,208,48,176,112,240,8,
              136,72,200,40,168,104,232,24,
              152,88,216,56,184,120,248,4,
              132,68,196,36,164,100,228,20,
              148,84,212,52,180,116,244,12,
              140,76,204,44,172,108,236,28,
              156,92,220,60,188,124,252,2,
              130,66,194,34,162,98,226,18,
              146,82,210,50,178,114,242,10,
              138,74,202,42,170,106,234,26,
              154,90,218,58,186,122,250,6,
              134,70,198,38,166,102,230,22,
              150,86,214,54,182,118,246,
              14,142,78,206,46,174,110,238,
              30,158,94,222,62,190,126,254,
              1,129,65,193,33,161,97,225,
              17,145,81,209,49,177,113,241,
              9,137,73,201,41,169,105,233,
              25,153,89,217,57,185,121,249,
              5,133,69,197,37,165,101,229,
              21,149,85,213,53,181,117,245,
              13,141,77,205,45,173,109,237,
              29,157,93,221,61,189,125,253,
              3,131,67,195,35,163,99,227,
              19,147,83,211,51,179,115,243,
              11,139,75,203,43,171,107,235,
              27,155,91,219,59,187,123,251,
              7,135,71,199,39,167,103,231,
              23,151,87,215,55,183,119,247,
              15,143,79,207,47,175,111,239,
              31,159,95,223,63,191,127,255};                                 //蝶形变幻的索引

/*-----------------------预计算表---------------------*/
static const int32_t zetas[N] = {
        0,    25847, -2608894,  -518909,   237124,  -777960,  -876248,   466468,
        1826347,  2353451,  -359251, -2091905,  3119733, -2884855,  3111497,  2680103,
        2725464,  1024112, -1079900,  3585928,  -549488, -1119584,  2619752, -2108549,
        -2118186, -3859737, -1399561, -3277672,  1757237,   -19422,  4010497,   280005,
        2706023,    95776,  3077325,  3530437, -1661693, -3592148, -2537516,  3915439,
        -3861115, -3043716,  3574422, -2867647,  3539968,  -300467,  2348700,  -539299,
        -1699267, -1643818,  3505694, -3821735,  3507263, -2140649, -1600420,  3699596,
        811944,   531354,   954230,  3881043,  3900724, -2556880,  2071892, -2797779,
        -3930395, -1528703, -3677745, -3041255, -1452451,  3475950,  2176455, -1585221,
        -1257611,  1939314, -4083598, -1000202, -3190144, -3157330, -3632928,   126922,
        3412210,  -983419,  2147896,  2715295, -2967645, -3693493,  -411027, -2477047,
        -671102, -1228525,   -22981, -1308169,  -381987,  1349076,  1852771, -1430430,
        -3343383,   264944,   508951,  3097992,    44288, -1100098,   904516,  3958618,
        -3724342,    -8578,  1653064, -3249728,  2389356,  -210977,   759969, -1316856,
        189548, -3553272,  3159746, -1851402, -2409325,  -177440,  1315589,  1341330,
        1285669, -1584928,  -812732, -1439742, -3019102, -3881060, -3628969,  3839961,
        2091667,  3407706,  2316500,  3817976, -3342478,  2244091, -2446433, -3562462,
        266997,  2434439, -1235728,  3513181, -3520352, -3759364, -1197226, -3193378,
        900702,  1859098,   909542,   819034,   495491, -1613174,   -43260,  -522500,
        -655327, -3122442,  2031748,  3207046, -3556995,  -525098,  -768622, -3595838,
        342297,   286988, -2437823,  4108315,  3437287, -3342277,  1735879,   203044,
        2842341,  2691481, -2590150,  1265009,  4055324,  1247620,  2486353,  1595974,
        -3767016,  1250494,  2635921, -3548272, -2994039,  1869119,  1903435, -1050970,
        -1333058,  1237275, -3318210, -1430225,  -451100,  1312455,  3306115, -1962642,
        -1279661,  1917081, -2546312, -1374803,  1500165,   777191,  2235880,  3406031,
        -542412, -2831860, -1671176, -1846953, -2584293, -3724270,   594136, -3776993,
        -2013608,  2432395,  2454455,  -164721,  1957272,  3369112,   185531, -1207385,
        -3183426,   162844,  1616392,  3014001,   810149,  1652634, -3694233, -1799107,
        -3038916,  3523897,  3866901,   269760,  2213111,  -975884,  1717735,   472078,
        -426683,  1723600, -1803090,  1910376, -1667432, -1104333,  -260646, -3833893,
        -2939036, -2235985,  -420899, -2286327,   183443,  -976891,  1612842, -3545687,
        -554416,  3919660,   -48306, -1362209,  3937738,  1400424,  -846154,  1976782
};

/*-----------------------具体函数----------------------*/
// bit反转， 蝶形变换 TODO 我自己给改成静态的了
/*void bitreverse(){
    int revint[N];
    for (int i = 0; i < N; ++i)
    {
        revint[i] = 0;
        rev[i] = i;
    }
    for (int i = 0; i < N; ++i){				// get rev
        revint[i] = (revint[i >> 1] >> 1) | ((i & 1) << (logN - 1));
        if(i < revint[i]){
            rev[revint[i]] = i;
            rev[i] = revint[i];
        }
    }
}*/

// 交换函数
void swap(int32_t &a, int32_t &b) {
    int32_t temp = a;
    a = b;
    b = temp;
}

// 模乘运算
void mulMod(int32_t &r, int32_t a, int32_t b, int32_t m) {
    __int128 mul = static_cast<__int128>(a) * b;
    mul %= static_cast<__int128>(m);
    r = static_cast<int32_t>(mul);
}

// 模指数运算
int32_t powMod(int32_t x, int32_t y, int32_t modulus) {
    int32_t res = 1;
    while (y > 0) {
        if (y & 1) {
            mulMod(res, res, x, modulus);
        }
        y = y >> 1;
        mulMod(x, x, x, modulus);
    }
    return res;
}
// 巴雷特模乘
// barrett Mul
void mulModBarrett(int32_t &r, int32_t a, int32_t b, int32_t m, int32_t pr){
    __int128 mul = static_cast<__int128>(a) * b;
    auto abot = static_cast<int32_t>(mul);
    auto atop = static_cast<int32_t>(mul >> 32);
    // int32_t pr = (static_cast<unsigned __int128>(1) << 2*(60+1)) / m;
    __int128 tmp = static_cast<__int128>(abot) * pr;
    tmp >>= 32;
    tmp += static_cast<__int128>(atop) * pr;
    tmp >>= 2*(primeLen + 1) - 32;
    tmp *= m;
    tmp = mul - tmp;
    r = static_cast<int32_t>(tmp);
    if ( r > m ) r -= m;
}
// 约减
int32_t REDC(int32_t a, int32_t b){
    __int128 U = static_cast<__int128>(a) * b;
    auto U0 = static_cast<int32_t>(U);
    int32_t U1 = U >> 32;
    int32_t Q = U0 * invp;
    __int128 Hx = static_cast<__int128>(Q) * pVec;
    int32_t H = Hx >> 32;
    int32_t V = U1 < H ? U1 + pVec - H : U1 - H;
    return V;
}

void NTT(int32_t a[N])
{
    int NLess2 = N >> 1;

    int32_t temp_a[N];
    for (int i = 0; i < NLess2; i++)
    {
        temp_a[i] = (a[rev[2 * i]] + a[rev[2 * i + 1]]) % pVec;
        temp_a[i + NLess2] = (a[rev[2 * i]] - a[rev[2 * i + 1]] + pVec) % pVec;
    }

    memcpy(a, temp_a, sizeof(temp_a));
    for (int i = 1; i < logN; i++){
        int shift = logN - 1 - i;
        for (int j = 0; j < NLess2; j++){
            int P = (j >> shift) << shift;
            int32_t odd = REDC(a[2 * j + 1], g[P]);
            temp_a[j] = (a[2 * j] + odd) % pVec;
            temp_a[j + NLess2] = (a[2 * j] - odd + pVec) % pVec;
        }
        memcpy(a, temp_a, sizeof(temp_a));
    }
}

void INTT(int32_t a[N])                                             //NTT，type=1, or is INTT
{
    int NLess2 = N >> 1;

    int32_t temp_a[N];
    for (int i = 0; i < NLess2; i++)
    {
        temp_a[i] = (a[rev[2 * i]] + a[rev[2 * i + 1]]) % pVec;
        temp_a[i + NLess2] = (a[rev[2 * i]] - a[rev[2 * i + 1]] + pVec) % pVec;
    }

    memcpy(a, temp_a, sizeof(temp_a));

    for (int i = 1; i < logN; i++){
        int shift = logN - 1 - i;
        for (int j = 0; j < NLess2; j++){
            int P = (j >> shift) << shift;
            int32_t odd = REDC(a[2 * j + 1], gi[P]);
            // mulModBarrett(odd, a[2 * j + 1], gi[P], pVec, prVec);
            temp_a[j] = (a[2 * j] + odd) % pVec;
            temp_a[j + NLess2] = (a[2 * j] - odd + pVec) % pVec;
        }
        memcpy(a, temp_a, sizeof(temp_a));
    }

    for (int i = 0; i < N; i++)
    {
        // mulModBarrett(a[i], a[i], inv, pVec, prVec);
        a[i] = REDC(a[i], inv);
    }

}
